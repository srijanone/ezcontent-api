<?php

namespace Drupal\ezcontent_api\EventSubscriber;

use Drupal\Core\Cache\CacheableResponseInterface;
use Drupal\Core\Config\ConfigFactoryInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;

/**
 * Class EzcontentJsonapiSubscriber
 * @package Drupal\ezcontent_api\EventSubscriber
 */
class EzcontentJsonapiSubscriber implements EventSubscriberInterface {

  /**
   * The config factory.
   *
   * @var \Drupal\Core\Config\ConfigFactoryInterface
   */
  protected $configFactory;

  /**
   * Constructs a EzcontentJsonapiSubscriber object.
   *
   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
   *   The config factory.
   */
  public function __construct(ConfigFactoryInterface $config_factory) {
    $this->configFactory = $config_factory;
  }

  /**
   * Add cache context to jsonapi routes.
   *
   * Unpublished nodes are made accessible using the token generated by
   * access_unpublished module. This token is passed as a query parameter in
   * the jsonapi url whose cache-context needs to be added for cache
   * invalidating.
   *
   * @param \Symfony\Component\HttpKernel\Event\FilterResponseEvent $event
   *   The event to process.
   */
  public function onResponse(FilterResponseEvent $event) {
    $request = $event->getRequest();
    $response = $event->getResponse();
    // Fetch the jsonapi path prefix from the config.
    $jsonapi_path_prefix = $this->configFactory->get('jsonapi_extras.settings')
      ->get('path_prefix');
    // Check if it's a jsonapi route.
    if (strpos($request->getRequestUri(), '/' . $jsonapi_path_prefix . '/') !== FALSE) {
      // Only act on CacheableResponse.
      if ($response instanceof CacheableResponseInterface) {
        // Fetch the access_unpublished token's hash_key from the config.
        $au_hash_key = $this->configFactory->get('access_unpublished.settings')
          ->get('hash_key');
        $response->getCacheableMetadata()
          ->addCacheContexts(['url.query_args:' . $au_hash_key]);
      }
    }
  }

  /**
   * {@inheritdoc}
   */
  public static function getSubscribedEvents() {
    $events[KernelEvents::RESPONSE][] = ['onResponse', 120];
    return $events;
  }

}
